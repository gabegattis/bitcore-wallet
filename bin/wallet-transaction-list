#!/usr/bin/env node
'use strict';

var _ = require('lodash');
var program = require('commander');
var http = require('http');
var https = require('https');
var fs = require('fs');
var url = require('url');
var bitcore = require('bitcore-lib');
var Address = bitcore.Address;
var Script = bitcore.Script;
var Transaction = bitcore.Transaction;
var Hash = bitcore.crypto.Hash;

var resultsPrinted = false;

program
  .option('-u, --url <url>', 'Server url to register with. Default: http://localhost:3001')
  .option('-f, --file <walletFile>', 'Wallet file to use. Default: ~/.wallet.json')
  .option('-d, --dates <dates>', 'Date range. Default: all-time')
  .usage('[options] e.g. wallet-transactions-list -f wallet.json -u http://localhost:3001 -d "2017-01-01 2017-04-01"' )
  .parse(process.argv);

var args = program.args;
var walletJSON = JSON.parse(fs.readFileSync(program.file));
var walletId = walletJSON.walletId;
var urlStr = program.url || 'http://localhost:3001';
var keys = getKeys(walletJSON);
var dateRange = parseDateRange(program.dates);
var network = getNetwork();

function isTLS(url) {
  return url.protocol === 'https:';
}

function getKeys(walletJSON) {
  var keys = {};
  walletJSON.keys.forEach(function(record) {
    var key = {};
    //keys[record.pubKey] = record.address;
    //keys[Hash.sha256ripemd160(new Buffer(record.pubKey, 'hex')).toString('hex')] = record.address;
    keys[record.address] = record.address;
  });
  return keys;
}

function getNetwork() {
  return Address.fromString(walletJSON.keys[0].address).network;
}

function parseDateRange(range) {
  var dates = range.split(/\s+/);
  return dates.map(function(date) {
    return new Date(date);
  });
}

function getTransactionList(walletId, dateRange) {
  var parsedUrl = url.parse(urlStr);
  var httpOptions = {
    protocol: parsedUrl.protocol,
    hostname: parsedUrl.hostname,
    port: parsedUrl.port || (isTLS(parsedUrl) ? 443 : 80),
    method: 'GET',
    url: urlStr,
    path: '/wallet-api/wallets/' + walletId + '/transactions?start=' +  dateRange[0].getTime() + '&end=' + dateRange[1].getTime(),
    params: { start: dateRange[0], end: dateRange[1] },
    body: ''
  };
  var error;
  var req = (isTLS(parsedUrl) ? https : http).request(httpOptions, function(res) {

    if (!goodStatusCode(res.statusCode)) {
      process.stderr.write('Response code from server was ' + res.statusCode + '\n');
      process.exit(-1);
    }

    var streamErr;
    res.on('error', function(err) {
      streamErr = err;
    });

    var buffer = '';
    //proper JSONL should be sent through the stream here. This means that each json object is demlimited by a newline character.
    //this also means that only objects are sent and not arrays
    res.on('data', function(chunk) {
      buffer += chunk.toString();
      buffer = parse(buffer);
    });

    res.on('end', function() {
      parse(buffer);
      if (streamErr) {
        throw streamErr;
      }
      if (!resultsPrinted) {
        console.log('no results.');
      }
    });

  });

  req.on('error', function(e) {
    console.error(e);
    process.exit(-1);
  });

  req.write('');
  req.end();
}

function parse(buffer) {
  var endOfTx = buffer.match(/}\n/);
  if (endOfTx) {
    var txStr = buffer.slice(0, endOfTx.index + 1);
    var obj = JSON.parse(txStr);
    transactionToList(obj);
    buffer = buffer.slice(endOfTx.index + 2);
  }
  return buffer;
}

function goodStatusCode(code) {
  if (code < 200 || code > 299) {
    return false;
  }
  return true;
}

function moveTransactionToList(transaction) {
  var list = [];
  var item = {
    transaction: transaction,
    type: 'receive',
  };
  item.satoshis = transaction.inputAmount;

  print(formatItem(item));

  item.type = 'send';
  item.satoshis = transaction.inputAmount * -1;

  print(formatItem(item));

  print(formatFeeItem(transaction));

}


function joinTransactionToList(transaction) {

  var self = this;

  var list = [];

  var printFeeLine = true;

  var item = {
    transaction: transaction,
    satoshis: transaction.delta,
    address: ''
  };

  if (transaction.delta > 0) {
    printFeeLine = false;
    item.type = 'shared-receive';
  } else if (transaction.delta < 0) {
    item.type = 'shared-send';
  } else {
    item.type = 'shared-equal';
  }

  if (printFeeLine) {
    print(formatItem(item));
  }

}

function isMove(transaction) {
  return transaction.allMine && transaction.inputAmount >= 0 &&
    (transaction.fee + transaction.outputAmount) === transaction.inputAmount;
}

function isJoin(transaction) {
  var ans = transaction.inputs[0].wallet;
  transaction.inputs.forEach(function(input) {
    if (ans !== input.wallet) {
      return true;
    }
  });
}

function labelTransactions(transaction) {

  var inputResults = aggregate(transaction.inputs);
  var outputResults = aggregate(transaction.outputs);

  transaction.inputs = inputResults.results;
  transaction.outputs = outputResults.results;
  transaction.inputAmount = inputResults.amount;
  transaction.outputAmount = outputResults.amount;
  transaction.delta = outputResults.amount - inputResults.amount;
  transaction.fee = inputResults.txAmount - outputResults.txAmount;
  transaction.allMine = inputResults.allMine && outputResults.allMine;
}

function aggregate(records) {

  var txAmount = 0;
  var amount = 0;
  var allMine = true;

  var results = records.map(function(record) {
    record.wallet = keys[record.address];
    if (!record.wallet) {
      allMine = false;
    }
    amount = record.satoshis;
    txAmount += record.satoshis;
    return record;
  });

  return { results: results, txAmount: txAmount, amount: amount, allMine: allMine };

}

function getAddressFromPubKeyOrHash(pubKeyOrHash) {
  if (pubKeyOrHash.length === 20) {
    return new Address(new Buffer(pubKeyOrHash, 'hex'), network).toString('hex');
  }
  return new Address(Hash.sha256ripemd160(new Buffer(pubKeyOrHash, 'hex'), network)).toString('hex');
}

function getPubKeyOrHash(scriptBuf) {
  var script = new Script(scriptBuf);

  //input p2pkh
  if (script.chunks && script.chunks[1] && script.chunks[1].len === 33) {
    return script.chunks[1].buf.toString('hex');
  }

  //output p2pk either compressed or uncompressed pubKey
  if (script.chunks && script.chunks[1] && (script.chunks[1].len === 33 || script.chunks[1].len === 65)) {
   return script.chunks[1].buf.toString('hex');
  }

  //output p2pkh
  if (script.chunks && script.chunks[2] && script.chunks[2].len === 20) {
    return script.chunks[2].buf.toString('hex');
  }

  //output p2sh
  if (script.chunks && script.chunks[1] && script.chunks[1].len === 20) {
    return script.chunks[1].buf.toString('hex');
  }

  //input p2sh
  if (script.chunks[script.chunks.length - 1] && script.chunks[script.chunks.length - 1].len > 75) {
    return Hash.sha256ripemd160(script.chunks[script.chunks.length - 1].buf).toString('hex');
  }

}

function transactionToList(transaction) {
  var self = this;

  var list = [];
  var printFeeLine = false;

  if (!_.isObject(transaction)) {
    throw 'provided transaction is not an object';
  }

  if (transaction.inputs.length < 1 || transaction.outputs.length < 1) {
    throw 'inputs and/or outputs are empty';
  }

  transaction.inputs.forEach(function(input) {
    if (input.satoshis < 0) {
      print(transaction);
      throw new Error('input satoshis not provided on one or more of the inputs, therefore we do not have enough information to build the report.');
    }
  });

  labelTransactions(transaction);

  if (isMove(transaction)) {
    return moveTransactionToList(transaction);
  }

  if (isJoin(transaction)) {
    return joinTransactionToList(transaction);
  }

  var delta = transaction.delta;

  for (var i = 0; i < transaction.outputs.length; i++) {
    var output = transaction.outputs[i];

    var line = '';
    if (delta > 0) { //means we are receiving money

      if (output.wallet) {
        var received = Math.min(output.satoshis, delta);
        delta -= received;
        line = formatItem({
          type: 'receive',
          transaction: transaction,
          address: output.address,
          outputIndex: i,
          satoshis: received
        });
      }

    } else if (delta < 0) {

      if (!output.wallet) {

        printFeeLine = true;

        var sent = Math.min(output.satoshis, delta * -1);
        delta += sent;
        line = formatItem({
          type: 'send',
          transaction: transaction,
          address: output.address,
          outputIndex: i,
          satoshis: sent * -1
        });
      }

    }

    if (line) {
      print(line);
    }

  }

  if (printFeeLine) {
    print(formatFeeItem(transaction));
  }

}

function print(line) {
  resultsPrinted = true;
  if (typeof line === 'undefined') {
    return;
  }
  process.stdout.write(JSON.stringify(line) + '\n');
}

function formatFeeItem(transaction) {

  if (!transaction.fee) {
    return;
  }

  var feeItem = {
    height: transaction.height,
    txid: transaction.hash,
    blockTime: transaction.timestamp,
    category: 'fee',
  };

  feeItem.satoshis = -1 * transaction.fee;
  return feeItem;
}

function formatItem (options) {

  var item = {
    height: options.transaction.height,
    txid: options.transaction.hash,
    blockTime: options.transaction.timestamp,
    category: options.type,
  };

  if (_.isString(options.address)) {
    item.address = options.address;
  }

  if (options.outputIndex >= 0) {
    item.outputIndex = options.outputIndex;
  } else if (options.inputIndex >= 0) {
    item.inputIndex = options.inputIndex;
  }

  item.satoshis = options.satoshis;

  return item;
}

getTransactionList(walletId, dateRange);
